#!/usr/bin/perl
#
# Copyright (C) 2007 Manuel Mausz (manuel@mausz.at)
# Copyright (C) 2015 Christian Jaeger (ch at christianjaeger ch)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


use strict; use warnings; use warnings FATAL => 'uninitialized';

# find modules
use Cwd 'abs_path';
our ($mydir, $myname); BEGIN {
    my $location= (-l $0) ? abs_path ($0) : $0;
    $location=~ /(.*?)([^\/]+?)_?\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/lib";

our $VERSION = '0.2';

my $debug=1;

use Mail::DKIM 0.29;
use Mail::DKIM::Signer;
use MySignerPolicy;
use ConfigMerge qw(config_merge);
use QmailExit ":all";
use HashCash qw(have_hashcash mint_hashcash);
use Spamscore ":all";
use DeliverMaildir 'deliver_wholemail_maildir';

# enable support for "pretty" signatures, if available
eval 'require Mail::DKIM::TextWrap';

my $configfile= '/var/qmail/control/dkim/signconf.xml';
my $maybe_debugfh= $debug && do {
    require Chj::xtmpfile;
    my $t= Chj::xtmpfile::xtmpfile ("/tmp/qmail-dkim_");
    $t->autoclean(0);
    $t
};
my $qremote= '/var/qmail/bin/qmail-remote.orig';
my $binary= 0;

our $config;

$config->{'global'} = +{
    types     => { dkim => {} },
    keyfile   => '/var/qmail/control/dkim/global.key',
    algorithm => 'rsa-sha256',
    method    => 'simple',
    selector  => 'global',
    # either string or file (first line of file will be used)
    domain    => '/var/qmail/control/me'
};

#-------------------------------------------------------------------------------

# read config file. safely
if (defined $configfile and -r $configfile) {
    eval 'use XML::Simple; 1' and do {
	my $xmlconf;
	eval {
	    $xmlconf = XMLin($configfile,
			     ForceArray => ['types'],
			     KeyAttr => ['id']);
	    1
	} || do {
	    qexit_deferral('Unable to read config file: ', $@)
	};
	config_merge($config, $xmlconf);
    };
}

# generate signatures
my $dkim;
my $mailbuf = '';

eval {
    my $conf = $config->{'global'};
    $dkim =
	Mail::DKIM::Signer->new(
	    Policy => MySignerPolicy->new($config),
	    Debug_Canonicalization => $maybe_debugfh
	);

    if ($binary) {
	binmode STDIN;
    }

    while (<STDIN>) {
	$mailbuf .= $_;
	unless ($binary)
	{
	    chomp $_;
	    s/\015?$/\015\012/s;
	}
	$dkim->PRINT($_);
    }
    $dkim->CLOSE();

    1
} || do {
    qexit_deferral('Error while signing: ', $@)
};


$maybe_debugfh->xclose
    if defined $maybe_debugfh;


# Check whether we really want to deliver this message: if it
# has a high spam score, don't.  Although, if those are locally
# generated messages, *iff* they ever get an SA score, then the
# refusal should be in the smtpd [or imapd] part, not here. What we
# really just want is, stop delivery of *bounces* of high-spamscore
# emails.

# Can't do this earlier since we had to read $mailbuf first.

sub stopit {
    # deliver to 'emergency' local account instead.
    my $maildir= '/var/qmail/Maildir_spambounce';
    deliver_wholemail_maildir $mailbuf, $maildir;
    qexit_success;
}

eval {
    if (my ($to_whom,$return_and_orig)= perhaps_wholemail_doublebounce $mailbuf) {
	warn "not sure how comes that we're trying to send a doublebounce";
	# should be impossible, qmail doesn't send double bounces
    } elsif (my ($return,$orig)= perhaps_wholemail_bounce $mailbuf) {
	if (my ($spamscore)= perhaps_wholemail_spamscore $orig) {
	    # likely spam to a non-existing address.
	    if ($spamscore > 3) {
		stopit;
	    }
	} else {
	    # original part is missing the spamscore (odd?, but), go
	    # on delivering it
	}
    } else {
	# not a bounce. still check spamscore, even though it should
	# never have one in the current setup, just to be sure...
	if (my ($spamscore)= perhaps_wholemail_spamscore $mailbuf) {
	    if ($spamscore > 5) {
		stopit;
	    }
	} else {
	    # no problem, deliver it
	}
    }
    1
} || do {
    #qexit_deferral('Error while checking: ', $@)
    # Printing to STDERR is ok, only STDOUT is used for signaling back, right?
    print STDERR "ignoring exception during spam check: $@";
};



my ($host, $sender, @recip)= @ARGV;

# execute qmail-remote
unshift(@ARGV, $qremote);
open(QR, '|-') || exec { $ARGV[0] } @ARGV
    or qexit_deferral('Unable to run qmail-remote: ', $!);

if (have_hashcash) { # XX add configuration option (instead)?
    my $bits= 23; # XX configuration option, too.
    for my $recip (@recip) {
	eval {
	    my $c= mint_hashcash $bits, $recip;
	    print QR $c
	      or qexit_deferral ('Printing to qmail-remote: ', $!);
	    1
	} or qlog "$@";
    }
}

for my $dkim_signature ($dkim->signatures) {
    my $sig = $dkim_signature->as_string;
    $sig =~ s/\015\012\t/\012\t/g;
    print QR $sig."\012"
	or qexit_deferral ('Printing to qmail-remote: ', $!);
}

print QR $mailbuf or qexit_deferral ('Printing to qmail-remote: ', $!);

close(QR) or qexit_deferral ('Sending to qmail-remote: ', $!);

# why is qexit_success never called? Because the piped-to qmail-remote
# issues it.
